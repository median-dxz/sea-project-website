---
sidebar_position: 7
---

# 收发包教程

EI PSY CONGROO

## 基础知识

对于网络游戏，收发包是客户端和服务端交互的方式，在这里使用的是 WebSocket，并且进行了一些封装。SEAC直接调用封装后的函数进行收发包。

对于一个普通的包，只需要知道它的最基本结构分为两部分：cmd和data。

其中 cmd 是一个u32，代表命令的id，一个cmd执行一个特定的内容。

data 是一组 u32，代表命令的具体内容。data也可能为空。

大部分收发包是客户端主动式的一问一答，基本上目前观察到的所有客户端发包都有回复。此外还有一些服务器的主动发包。

此外还有就是一些特殊的包游戏内提供了进一步的封装，目前有MultiValue，BitSet和PlayerInfo。这些相当于进行指定的服务端数据查询，MultiValue和PlayerInfo都是查整数值，BitSet则是查布尔值。

## 获取收发包

进行收发包的第一步是进行收发包的获取，要判断这个功能是否需要收发包来完成，只需要判断该功能的逻辑是否涉及服务端交互。但是还是建议阅读源码来了解具体某个包的发包包体约束以及收包包体的规则。

通常来说，首先第一步是通过抓包等手段获得目标包（可能不止一个）的id。

之后是通过该id反查源码找到具体的发包逻辑。同时找到收包后每个u32对应的含义。

## 发包

获取完以上信息后，就可以进行收发包了，SEAC的发包函数位于socket命名空间下。这里只介绍基础的 `sendByQueue`。其他进行数据查询的函数请参阅[socket 命名空间](./engine.md#socket-命名空间)。

sendByQueue的名称内带有ByQueue，强调该发包是按序收发的，不会出现乱序的情况。实际上游戏内的包并没有带上唯一标识，收发包的顺序需要手动保证。具体来说
